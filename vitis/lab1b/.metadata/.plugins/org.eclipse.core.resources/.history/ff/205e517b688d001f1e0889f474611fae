/*
 *timing.c: simple starter application for lab 1A and 1B
 *
 */

#include <stdio.h>		// Used for printf()
#include <stdlib.h>		// Used for rand()
#include "xparameters.h"	// Contains hardware addresses and bit masks
#include "xil_cache.h"		// Cache Drivers
#include "xintc.h"		// Interrupt Drivers
#include "xtmrctr.h"		// Timer Drivers
#include "xtmrctr_l.h" 		// Low-level timer drivers
#include "xil_printf.h" 	// Used for xil_printf()
#include "extra.h" 		// Provides a source of bus contention
#include "xgpio.h" 		// LED driver, used for General purpose I/i
#include "sevenSeg_new.h"
#include <unistd.h>

#define NUMBER_OF_TRIALS 10000
#define NUMBER_OF_BINS 3
#define BUFFER_SIZE (1024*1024)
unsigned int buffer[BUFFER_SIZE]; //buffer for read/write operations to the DDR memory

/*
 * The following constant is used to determine which channel of the GPIO is
 * used for the LED if there are 2 channels supported.
 */
#define LED_CHANNEL 1

void histogram(void); // This function creates a histogram for the measured data
void display(int);
int div10(int);
int div1000(int);
int mod10(int);

/*
 * The following are declared globally so they are zeroed and so they are
 * easily accessible from a debugger
 */
XGpio Gpio; /* The Instance of the GPIO Driver used for LED 0 */

/*
 * This globally declared array stores the
 * number of clock cycles for all the trials.
 * With global declaration, it is stored in the data segment of the
 * memory. Declaring this large array locally may cause a stack overflow.
 */
int numClockCycles[NUMBER_OF_TRIALS];

//Stores the number of samples in each bin
int histData[NUMBER_OF_BINS];

//BaseAddr points to the base (byte) address of the DDR2 Memory
u8 * BaseAddr = (u8 *) XPAR_MIG7SERIES_0_BASEADDR;

/*
 * REPEAT is a somewhat dangerous macro that makes multiple statements from an
 * input string. The danger is statements like if() without {}... Here this is
 * no problem, but beware if you use it elsewhere -- macro bugs are often very
 * hard to debug.
 */
#define REPEAT_5(X) X;X;X;X;X
#define REPEAT_10(X) REPEAT_5(X);REPEAT_5(X)
#define REPEAT_15(X) REPEAT_10(X);REPEAT_5(X)
#define REPEAT_20(X) REPEAT_15(X);REPEAT_5(X)
#define REPEAT_25(X) REPEAT_20(X);REPEAT_5(X)
#define REPEAT_40(X) REPEAT_15(X);REPEAT_25(X)

int prev = -1;

int main() {
    // Caches enabled here -- Diasble if you want alternate measurements
	Xil_ICacheInvalidate();
	Xil_ICacheEnable();
	Xil_DCacheInvalidate();
	Xil_DCacheEnable();

	// Extra Method contains an interrupt routine which is set to go off at timed intervals
	extra_method();

	//TIMER RESET CODE
	//Turn off the timer
	XTmrCtr_SetControlStatusReg(XPAR_TMRCTR_0_BASEADDR, 1, 0);
	//Put a zero in the load register
	XTmrCtr_SetLoadReg(XPAR_TMRCTR_0_BASEADDR, 1, 0);
	//Copy the load register into the counter register
	XTmrCtr_SetControlStatusReg(XPAR_TMRCTR_0_BASEADDR, 1, XTC_CSR_LOAD_MASK);
	//Enable (start) the timer
	XTmrCtr_SetControlStatusReg(XPAR_TMRCTR_0_BASEADDR, 1,
			XTC_CSR_ENABLE_TMR_MASK);
	//END TIMER RESET CODE

	//INITIALIZATION FOR AXI GPIO LED PORT
	XGpio_Initialize(&Gpio, XPAR_AXI_GPIO_LED_DEVICE_ID);

	while(1 == 1){
		display(count);
	}
}

int div10(int val){
	return (val * 41) >> 12;
}

int div1000(int val){
	return (val * 131) >> 17;
}

int mod10(int val){
	int mod = val - 10 * div10(val);
	if(mod > 10){
		mod = mod10(mod);
	}
	return mod;
}

void display(int interval){
	int d0, d1, d2, d3, d4, d5;

	//interval = 999999 - interval;

	d0 = interval % 10;
	//sevenseg_draw_digit (2, d0);
	d1 = mod10(div10(interval));
	sevenseg_draw_digit (3, d1);
	d2 = mod10(div10(div10(interval)));
	sevenseg_draw_digit (4, d2);
	d3 = mod10(div1000(interval));
	sevenseg_draw_digit (5, d3);
	d4 = mod10(div1000(div10(interval)));
	sevenseg_draw_digit (6, d4);
	d5 = mod10(div1000(div10(div10(interval))));

	sevenseg_draw_digit (7, d5);
	//xil_printf("%d\t", d1);
}


